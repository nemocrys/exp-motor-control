// Regulate and measure rotation speed of 4 wire PC fan.
// optional: potentiometer 10K connected between GND and 5V
// optional: potentiometer wiper to analog input A0 controls fan speed
// Fan TACHO speed connected to digital pin D2

int icr, frequency, duty_cycle, PotentiometerValue;

// tacho variables
int RPM, TachoPulse = 0;
unsigned long StartTime;

// PWM ramp variables
int startValue = 100;    // Minimum PWM value (0 = 0% duty cycle)
int endValue = 100;    // Maximum PWM value (100% duty cycle)
const float initTimeMinutes = 0; // Initial delay in minutes 45 + (11 * 60)
const float rampTimeMinutes = 60; // Ramp time in minutes
bool rampPaused = false;
bool rampReversed = false;
bool rampComplete = false;
unsigned long lastUpdate;
unsigned long delayPerStep;

void setup() {
  Serial.begin(9600);
  pinMode(11, OUTPUT);   // Fan PWM connected to digital PWM pin. Arduino UNO pin 9, Arduino MEGA pin 11
  digitalWrite(2 ,HIGH); // Internal pull up resistor
  attachInterrupt(digitalPinToInterrupt(2), counter, RISING); // tacho pin of fan attached to digital_in 2 
  // Timer/Counter 1 initialization
  TCCR1A = 0xA2;
  TCCR1B = 0x19;
  TCNT1H = 0x00;
  TCNT1L = 0x00;

  icr = 639; // icr and frequency values are set to generate a 25 kHZ signal
  frequency = 16000000 / (1 + icr);

  ICR1H = icr >> 8;
  ICR1L = icr & 0x00ff;

  duty_cycle = startValue;
  int steps = abs(endValue - startValue);
  delayPerStep = (rampTimeMinutes * 60.0 * 1000.0) / max(steps, 1);

rampComplete = true; // set FALSE to enable ramp
//rampReversed = true; // code to reverse ramp
  if (rampReversed  && !rampComplete) {
    int temp = startValue;
    startValue = endValue;
    duty_cycle = endValue;
    endValue = temp;
    // analogWrite(PWM_PIN, duty_cycle);
  }
  
  lastUpdate = millis();
  OCR1A = icr * (duty_cycle / 100.0); // initialize duty cycle
  
  //Serial.println("Waiting 5 sec before first Tacho measurement...");
  //delay(5000);
  Serial.print("Duty cycle = "); Serial.println(duty_cycle);
  Serial.print("%; Waiting for "); Serial.print(initTimeMinutes); Serial.print(" minutes / "); Serial.print(initTimeMinutes / 60.0); Serial.println(" hours before starting ramp...");
  delay(initTimeMinutes * 60.0 * 1000.0); // initial delay
}

void loop() {
  // Count number of interrupts generated by tacho of fan for 1 second
  StartTime = millis();      // start measuring RPM
  TachoPulse = 0;            // zero TachoPulse, will be incremented with 2 for each rotation
  while((millis() - StartTime) < 10000) {} // count number off interrupts during 10 second
  RPM = TachoPulse * 3;     // RPM = interrupts per seconds * 60 / 2 (2 tacho pulses per rotation)
  // Print current duty cycle and fan speed on the serial monitor:
  Serial.print("Duty cycle = "); Serial.print(duty_cycle); Serial.print(" %  ; Speed (rpm) = "); Serial.println(RPM);

  
  // Ramp routine
  if (!rampComplete && millis() - lastUpdate >= delayPerStep) {
    lastUpdate += delayPerStep;
    if (endValue > startValue && duty_cycle < endValue) {
      duty_cycle++;
    } else if (endValue < startValue && duty_cycle > endValue) {
      duty_cycle--;
    } else {
      rampComplete = true;
    }
    // analogWrite(PWM_PIN, duty_cycle);
    OCR1A = icr * (duty_cycle / 100.0); // Set the duty cycle
  }
  else if (rampComplete) {
    // When ramp is complete, duty_cycle stays at final valueâ€”no action needed
    delay(10000); 
  } 
}

void counter() {
  TachoPulse++;  // Count the number of times a interrupt is generated
}
